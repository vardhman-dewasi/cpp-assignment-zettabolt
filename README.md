# TPC-H Query 5 Implementation in C++ (Multithreaded)

This project implements TPC-H Query 5 ("Local Supplier Volume") in C++ using multithreading and raw `.tbl` data files generated by the TPC-H `dbgen` tool.


## Project Features

* Fully in-memory processing (no DBMS)
* CLI-based parameter control (region, date range, thread count, paths)
* Multithreaded order processing for better performance
* Outputs sorted revenue per nation


## Dependencies

* C++17 or later
* Standard C++ STL libraries (no external dependencies)


## Project Structure

```
tpch_q5_project/
├── include/
│   ├── tpch_structs.h         # Struct definitions for all tables
│   ├── file_reader.h          # Declarations of functions to load tables
│   └── cli_parser.h           # CLI argument parser header
│
├── src/
│   ├── file_reader.cpp        # Data loading from .tbl files
│   └── cli_parser.cpp         # CLI argument parsing logic
│   └── main.cpp               # Main multithreaded logic + CLI integration
├── data/                      # Directory containing .tbl files (generated from dbgen)
├── output.txt                 # Output results after execution
└── README.md                  # Project explanation & setup instructions
```


## Steps to Run the Project

### 1. Clone or Download

```bash
git clone https://github.com/vardhman-dewasi/cpp-assignment-zettabolt.git
cd cpp-assignment-zettabolt
```

### 2. Generate TPC-H Data (Optional if you already have `.tbl` files)

* Download and compile `dbgen` tool from the TPC-H benchmark.
* 
    1.Go to the official TPC-H GitHub repository- https://github.com/electrum/tpch-dbgen

    2.Clone the repository:

    ```bash
    git clone https://github.com/electrum/tpch-dbgen.git
    cd tpch-dbgen
    ```
    3.The DBGEN tool is written in C, so you need to compile it.

    ```bash
    make
    ```
    4.This creates an executable called dbgen.

* Generate data:

```bash
./dbgen -s 1     # Generate SF1 (scale factor 1) dataset
```

* Move all `.tbl` files to the `./data/` directory of your project.

### 3. Compile the Project

```bash
g++ -std=c++17 -O2 -pthread main.cpp src/cli_parser.cpp src/file_reader.cpp -o main
```

### 4. Run the Executable

```bash
./main ASIA 1995-01-01 1996-01-01 4 ./data/ output.txt
```

### CLI Parameters:

```
<REGION>        : Region name to filter (e.g., ASIA)
<START_DATE>    : Start of order date (inclusive)
<END_DATE>      : End of order date (exclusive)
<NUM_THREADS>   : Number of threads for processing
<DATA_DIR>      : Path to directory containing .tbl files
<OUTPUT_PATH>   : Output file path for final result
```


## Sample Output (`output.txt`)

```
Final Revenue by Nation :
INDIA: 51234000.45
CHINA: 50122344.20
...
Execution Time: 0.562 seconds
```



## How It Works - Step-by-Step

### The TPC-H Schema

### [Tpch Schema] (https://drive.google.com/file/d/1gfbhCIOMXQrj8jspw2VKzz3jtV6xXPWw/view?usp=sharing)


### Step 1: Data Preparation

* Use `dbgen` to generate `.tbl` files for tables: region, nation, customer, supplier, orders, lineitem.

### Step 2: Read Data

* Custom parsers read each `.tbl` file and convert rows into `struct` vectors.

### Step 3: CLI Interface

* User provides region, date range, thread count, paths.
* Parameters are parsed using `cli_parser.cpp`.

### Step 4: Multithreaded Processing

* Orders are divided among N threads.
* Each thread:

  * Filters orders by date range and region
  * Joins with customer, nation, supplier
  * Calculates local revenue

### Step 5: Aggregate & Output

* Mutex protects shared revenue map.
* Final results are sorted and written to `output.txt`.


## Generating a Performance Report

Follow these steps to create a meaningful performance comparison report:

* Execute the Program
  Launch the application using your selected parameters (e.g., region, date range, thread count).

* Capture the Output
  The results, including total revenue and execution time, will be saved to your specified output path.

* Analyze and Compare
  Review the output to assess how performance scales between single-threaded and multi-threaded executions. Highlight speed gains and identify any bottlenecks.

## How Multithreading Boosts Performance
Here's the rationale behind the observed speedup when leveraging multithreading:

* Parallel Workload Distribution
  Tasks are split across multiple threads, allowing simultaneous execution and significantly reducing total processing time.

* Task Efficiency
  Multithreading accelerates:
    * I/O-bound tasks like reading large .tbl files
    * CPU-bound tasks such as joining and aggregating data
  This dual optimization improves overall throughput.

## Scalability with Threads
Performance typically improves with more threads—up to the point where thread management overhead (e.g., context switching) outweighs the benefits.

## Credits

* TPC-H Benchmark ([www.tpc.org](http://www.tpc.org))
* Designed and implemented by Vardhman (2025)


## Questions?

Feel free to reach out or fork this repo to build on it!
